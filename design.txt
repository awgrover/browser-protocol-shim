Design & Specs

Goals

1. Provide a framework for more easily implementing "protocols" (URL "schemes").
1. Provide a secure framework for html/js/jvm apps without needing a server. 
1. Provide a framework for integrating local apps into the browser, which should be a side-affect of the above.
1. Leverage same-origin-policy to provide security for web-apps, e.g. "localhost" based ones.
1. Provide simple recipes for the above, for certain simple cases. E.g. turn a web-page into a web-app that is not limited to SOP.
1. Manage the security issues between these apps.
1. Provide a user-friendly way to manage these "apps" (including installation), that helps the user understand and control security issues.
1. Inspire a better solution for the above, or at worst, get this solution used widely for the above.
1. Make the solution cross-platform, and easy to to manage cross-platform.
1. Initial implementation for IE and Firefox.

Some Philosophy.

The solution should be cross-browser, which leads one to try to minimize the platform dependant core(s). Move everything into JS or java-bytecode, make the core an api/abstraction. 

Prefer JS, because the engine is already loaded.

Make the framework a meta shim, as much as possible. Thus, we can use itself to manage itself. And, we eat our own dogfood.

Allow the programmer to choose their language and technologies as much as possible. Allowing the JVM is an easy win.

Try to keep "grant least authority", and "capability security model" as guiding principles.

Look for opportunities to make recipes for useful solutions.

Try to use existing browser mechanisms for all features (e.g. can we use the "install extension/add-on" for a shim?). 

Try to conform to existing web expectations so the user isn't frustrated or surprised in a bad way.


Coding Standards

Conform to the generally accepted standards for the appropriate language/environment. E.g., the IE "Bottom" would probably be in some .net language with whatever intercap/underscore/indent/naming convention.

* Can we find and use a _super simple_ wiki markup? I'm sorta using one here.
    paragraph
    h1/h2
    emphasis (e.g. underline)
    nested ordered/unordered bullets
    http link
    uh... "code"
    ??
    
* Use spaces for indentation, not tabs unless the overwhelming convention is not to. Thus, on all non-MS-only files, use spaces. I prefer 2. But, either 2 or 4 (8 if the overwhelming convention is 8).

* Prefer underscore identifiers (e.g. "some_identifier_name") to intercaps. Unless overwhelming convention, etc. (e.g. Ruby classes).

* Above the "Bottom" layer, prefer to throw errors, do not return them. Thus, don't do
    # this is bad:
    status = register(...)
    if status == 'ok'
        proceed...
    else
        do some fail worthy thing

* Prefer plain text. E.g. avoid ".chm".


"Bottom", The Browser-Dependant Core

"Bottom" is the minimal core that has to be browser-native code. Obviously, somewhat dependant on the lcd of the supported browsers. One "Bottom" for each browser.

I'm assuming that "Bottom" will provide functions to JS.

1. Key Issues Tests

(This is an early priority, but it is probably more understandable to read the other sections for "Bottom" (below) first, and then come back to this).

* "Like http" test

We want installed protocol handlers to cause rendering of HTML. So do a minimal test that shows that an arbitrary protocol-handler causes:
 
    * HTML to be rendered in the browser
    * fetching indicated assets (e.g. <img src="...">, css, js)
    * executes JS from <script>
    * executes JS from <script src="....">
    * maintains cookies
    * the correct "referer" for requests from the newprotocol: url.
    * a redirect to work.
    * the correct reaction to certain '5xx' codes: typical browser behavior (uh, 501?)

* Same-origin-policy test

This is key to the desired behavior. Do minimal test first! Construct test code, in the easiest manner possible, that tests this:
    * Same origin
        * nonhttp://likeanurl/x
        * nonhttp://likeanurl/y
    * Different origin, using a real-url that you can return content for (static ok):
        * nonhttp://likeanurl/x
        * nonhttp://a.real.url/x
        * nonthttp://b.real.url/x
        * http://a.real.url/x
    * The test would be simply some js in the page that tries to fetch from the urls (start at one of the urls), load each one, having the same html:
        <script>
            // This is psuedo-javascript
            insert_html_at_bottom_of_page( "I'm: "+this_pages_url + "<br>");
            
            // try each of those urls shown above
            urls = [ 'nonhttp://likeanurl/x', '....' ];
            urls.each_with_index( function(the_url) {
                response = nil;
                error = nil;
                try {
                    response = ajax.get(the_url); 
                    }
                catch(e) {
                    error = "Threw: "+e.to_string();
                    }
                html_fragment = ''
                if error != nil
                    html_fragment = 
                        response.status + " : " +
                        response.body;
                else
                    html_fragment = error
                
                insert_html_at_bottom_of_page(
                    the_url + " : " + html_fragment
                   );
         <script>
 
cf. Example of adding a protocol to FF: http://www.nexgenmedia.net/docs/protocol/

* Test Sandboxing (from below). Otherwise security behavior is severely compromised. Show "interpreting" of a js string:
    * that interprets correctly using an object supplied via the environment
    * that causes a "undefined" error for a object that would normally be visible in the lexical context (e.g. native object/method), but we want to exclude (e.g. "add protocol handler").
    * that causes an error for normal, but unsafe operations (i.e. File.open), as expected in a normal web-page page
    * that works correctly for safe objects (what other normal JS objects?)
    * that returns the defined top-level variables
    * that acts as if the same-origin-policy mismatches on _all_ origins        
    * the returned dictionary from interpreting the string can invoke the returned objects (again showing the above behaviors), or the equivalent.

                
1. Namespace
See "Shim Framework" below. Assume that this api is in a namespace/object/class (called "X" here). This namespace must be sandbox'able (not visible to certain JS, e.g. the client code for shim "someprotocol:").

1. Register a "protocol" (URL "scheme") with the browser.

    try
        X.register(handler, protocol, default_port)
    catch
        ...

* If this fails, "some exception" is thrown.
* registering the same protocol multiple times should throw.
* "handler" is a JS object with a CGI like api:
    response = handler(request)
** "request" is an object with the standard CGI "environment variables". See "Request Object" below
** A response-object is returned (see "Response Object" below).
** The handler() function should not throw an exception. The register() function must prevent any such thrown exception from causing bad behavior. Thus, register() may silently catch any exception from handler().
    
* Throws ???
    
* "protocol" is the URL "scheme" component, without ":", e.g. "http", "P2P", "BobsYourUncle".
* We assume that the protocol has attributes that are consistent with http/https:
** always returns a (http like) response
** safe for any other http url to load (consider xss, e.g. file: is _not_ safe)
** standard scheme://user:pass@host-like/path structure
** relative urls make sense (relative to host)
** security "context" depends on host-portion.
** apply same-origin-policy as per http:, e.g. based on host part.
** but is not proxy'able
** can make the browser act like https does with respect to indicating "secure". How close can we get to this?

cf. firefox: http://www.nexgenmedia.net/docs/protocol/


Questions/Issues
* FF automatically forbids certain ports (e.g. 25). Does IE? We assume that is OK?
* Namespacing/sandboxing? How does it work? Punt for alpha version.
* Exceptions need to be (relatively) uniform between FF & IE. 
* what does IE & FF do if you try to register the same protocol? That _must_ throw.* FF allows a flag for "does not hit network". Presumably, this allows the protocol to continue to work "offline". Does IE have this behavior? We should allow this if possible.
* Should we allow a "port" portion of the url (e.g. "p2p://somehostpart:321/..."). Maybe a "protocol" actually cares? I propose that we pass the allowed-ports argument to pass-thru from the particular shim.
* Presumably the "protocol" is case sensitive?
* FF wants a "turn a utf-8 URI into internal URI structure" function. Does IE need that?
* In FF, "Handler"
* Threads
** FF has restrictions on certain things: which threads certain calls may be made from.
* "secure" (e.g. https-like) behavior: can we get behavior that is analogous? "secure" indicator in url/status bar? "mixed-mode"? effects on security context? Per-request, or per-protocol? It appears that we can indicate "https-like" to FF....

1. Request Object 

* Provides attributes(?) of the standard CGI "variables":
    e.g. "METHOD", "REFERER", etc.
    see http://www.ietf.org/rfc/rfc3875
** Should the request object implement the variables as attributes or getters? If getters, you may not have to copy values into an attribute.

* The body (e.g. for POST) as a string
    body()

** "protocol specific meta variables", e.g. "HTTP_xx" which correspond to the http: protocol headers are not relevant(?)
** AUTH_TYPE may be necessary, presumably we want that to work....
** We should do something appropriate for PATH_TRANSLATED vs. 
** REMOTE_ADDR and REMOTE_HOST are '127.0.0.1' and 'localhost' respectively.
** SCRIPT_NAME ?
** SERVER_NAME (etc) is the host-part of the uri.
** we assume 
    GATEWAY_INTERFACE = "CGI/1.1"
    SERVER_SOFTWARE = "shim/$version ($user-agent)
        where 
            $version is the version of the shim (e.g. "0.1"), 
            $user-agent is the standare user-agent as reported in the http header.
                e.g. "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)"

1. Response Object

An object that represents a "CGI Response" (not "NPH").

* It is has the headers as an array(?)
    headers()
* It has the content as a string
    content() # possibly the empty string
* A few specific functions that correspond to headers
    content_type() # null if no such header
    status() # a string
    location() # null if no such header
    content-length() # is the same value as content().length()   
* To make the Bottom's implementation easier, a number of things are more strict than the RFC.    
* Case is significant, and must conform to exemplar field-names in RFC 3875 (for cgi 1.1). (Note, the RFC specifies that the field-names are _not_ case-sensitive, but we will require them to be so at this level of the api).
* Values are verbatim as following the ":", including the case of the empty string (zero characters after :), values with a double-quote (")
** Note that double-quoted values do specify how to handle an embedded (escaped) double-quote.
** Values must not contain any vertical-space (e.g. new-line).
* Header and value text is assumed UTF-8 (despite the RFC specifying iso8951)
* Values must be correctly constructed/quoted.
* No spaces must follow the ":" in a header line (despite optional space as in the RFC).
* The "Status" must always provided (despite being optional in the RFC). An "xxx" exception may (must?) be thrown if not provided.
* The "Location" header must hold a URL encoded, absolute URI.
* Content-Length
* Hints:
** A "Redirect" response is distinguished by a "Location" header. Use location() to determine if this is a redirect. It may have content.
** A "Document" response has content for the browser, at least a "Content-Type" header, and does _not_ have a "Location" header.
** Header fields are formatted like "FieldName:value stuff"
*** "value stuff":
    may be the empty string
    may have (unquoted) punctuation
    may be a single token (no double-quotes, no whitespace)
    or a double-quoted (") string
    or a sequence of tokens & strings & punctuation
    Despite the RFC's BNF, newline is not permitted in a header line
    there is no provision for escaping the double quote
** All status values may have content
** Redirects always have a status of '3xx' and a 'Location' header. But, check the  "Location' header as the controlling factor! See "Redirects" below.
* Timeout? Implement timeout in "Shim Framework", not here.
* Should this be an array of the header _lines_ (e.g. "Status 202"), or should it be a dictionary (hash), e.g. { 'Status' : '202' }. Nb: the RFC specifies that headers are unordered. 
* We want HTTP-like behavior. The browser-native HTTP machinery should be used to process the response (esp. redirects). Issues?
** E.g. it should render the body as if HTML under HTTP 1.1, running javascript, etc.

Same-Origin-Policy

A key behavior is that the rendered page _must_ use the request's "host" for the same-origin-policy.

Redirects

Should a response be a redirect, the browser should be made to react appropriately. Note that the CGI RFC (and HTTP protocol) allow content for a redirect. That content (and appropriate) headers should be passed to the native browser interface so that debugging software may log it. It may be that the content is used in certain other contexts (e.g. accessibility contexts, controls, add-ons).

Redirects without content must be status '302'. Redirects with content may be any status that indicates a redirect (should be some '3xx').

Note that we want HTTP-like behavior, so a '304' is a permanent redirect. It might have side-effects (such as updating a bookmark). 

1. Sandbox Execution for A Protocol

To prevent an installed protocol from hijacking the world, we want to limit the sorts of things it can do. Thus, the code should be sandboxed such that it can _not_ call any native browser method directly.

We must be able to provide an interface(s) that it can call that can perform checked calls to the native-browser. E.g. An installed protocol may be allowed to connect to a local file, communicate over UDP to arbitrary addresses, etc.

Thus, we need the equivalent of:
    interpret some javascript, 
    in an environment (binding)
    that has _only_ these objects/functions,
    allowing standard language objects (like "array") of course,
    returning the environment (binding).

I use "environment" here to mean the equivalent of:
    A dictionary,
    where the keys are JS names (variables/functions/objects),
    and the values are the corresponding objects,
    that are treated like pre-defined names in the interpreter.

For example, I would want to:
    sandbox_world = interpret_in_sandbox(
        "some javascript....",
        {Response : function(....) }
        );
And the "some javascript" could use "Response". And the returned sandbox_world would be a dictionary of the defined top-level names in "some javascript". Which I could then use.

NB: The supplied environment must be immutable, the values in the environment must be immutable, and the functions in the values must be opaque (must not have any internals that can be made visible to the sandboxed JS.).

NB. I believe there are some objects/functions that are defined by JS that must be made subject to a security regime: e.g. File.open() sort of thing. Thus, in addition to the supplied environment, we must be able to indicate a security regime of "no external objects", approximately equivalent to JS code in a browser-page (where the "origin" of same-origin-policy is no "origin" matches "my origin").

* Providing JS Functionality to a Page

Some installed protocols will need to provide functions to their page(s)? err, haven't thought this through.


Shim Framework

Issues


* Protocol is case-sensitive. But disallow protocols that differ only in case (to prevent confusion)?






