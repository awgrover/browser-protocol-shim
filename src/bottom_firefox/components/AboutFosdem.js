try{
// Do not edit this file, generated from: src/bottom_firefox/components/AboutFosdem.js.tmpl
/*
 *             DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
 *                    Version 2, December 2004
 *
 * Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>

 * Everyone is permitted to copy and distribute verbatim or modified
 * copies of this license document, and changing it is allowed as long
 * as the name is changed.

 *           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
 *  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 * 0. You just DO WHAT THE FUCK YOU WANT TO.
 * Author: Bogomil "Bogo" Shopov <shopov.bogomil@gmail.com>
 * 
 * 
 * Thanks goes to: Mike Kaply && Wladimir Palant for their help and code
 * 
 * */



/*
 * include components and functions we need to create a new protocol
* */

function debug() { for(var i=0; i<arguments.length; i++) {dump(arguments[i]);dump(" ");}; dump("\n") };

const Ci = Components.interfaces;
const Cc = Components.classes;
const Cr = Components.results;
const nsIProtocolHandler = Ci.nsIProtocolHandler;
Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");

/*
 * function to detect is a value a number or not
 * */
 
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

/*
 * function to handle requests.
 * Based on the value after fosdem:
 * */
function  WhereToGo(fres){
    return 'http://localhost:5984/'+fres.host+(fres.path ? fres.path : '');
    }

function AboutFosdem() {
}

AboutFosdem.prototype = {
  scheme: "couchdb",
  protocolFlags:nsIProtocolHandler.URI_STD | // |  nsIProtocolHandler.URI_NORELATIVE |
                 // nsIProtocolHandler.URI_NOAUTH |
                 nsIProtocolHandler.URI_LOADABLE_BY_ANYONE,

  to_http_scheme : function(uri) {
    var db_name = uri.host;
    var path = uri.path ? uri.path : '';
    if (db_name == '' && path.substr(0,1) ==  '/') { path = path.substr(1) } // we end up with http://localhost:5894/<nodb>/ otherwise
    var spec = 'http://localhost:5984/'+db_name+path; // FIXME: this is the "to" pattern
    debug("Converted tohttp",uri.spec," => ",spec);
    return this.make_nsIURL(spec);
    },

  allow_http_root : true, // FIXME: per scheme thing

  from_http_scheme : function(uri) {
    // uri must be absolute
    // FIXME: this is the "lift domain" pattern
    if (uri.path.substr(0,1) != '/') { throw "FAIL: Need absolute uri, saw "+uri.spec };

    var [dumy, db_name, rest_of_path] = uri.path.match(/^\/([^\/]+)?/);
    if (!db_name) {
        if (this.allow_http_root) {
            db_name = '';
            }
        else {
            throw "FAIL: Need first path piece for _our_ scheme to lift to domain: "+uri.spec+", path is "+uri.path
            }
        }
    debug("Converted fromhttp",uri.spec,"to db",db_name," w/rest",rest_of_path);
    var spec = 'couchdb://'+db_name+(rest_of_path || '');
    return this.make_nsIURL(spec);
    },

  make_nsIURL : function(spec, originCharset, baseURI) {
      debug("Make",spec,' vs ',baseURI && baseURI.spec);
      var stdURL = Components.classes["@mozilla.org/network/standard-url;1"].createInstance(Components.interfaces.nsIStandardURL);
      stdURL.init(Components.interfaces.nsIStandardURL.URLTYPE_STANDARD, -1, spec, originCharset, baseURI);
      return stdURL.QueryInterface(Components.interfaces.nsIURI); // standardurl is not a subclass! .spec will be undefined!
      },

  adjust_relative_path : function(aSpec, aBaseURI) {
    // because nsIStandardURL doesn't do leading "../"

    // Don't bother trying to do relative path if no base or no leading ../
    if (aBaseURI == null || aSpec.substr(0,3) != '../') { return [ aSpec, aBaseURI ] }

    var backoff = 0;
    while (aSpec.substr(0,3) == '../') {
        aSpec = aSpec.substr(3);
        backoff += 1;
        }
    if (backoff > 0) {
      debug("[backoff]",backoff);
      base_path = aBaseURI.path;
      while (backoff > 0) {
        // trim off /blah (leaving initial "/")
        base_path = base_path.replace(/(.)\/([^\/]+)?$/,'$1');
        backoff--;
        }

      debug("   base became",base_path);
      base_path = base_path.replace(/[^\/]+$/,'');

      aBaseURI = this.make_nsIURL(
        aBaseURI.scheme + ":"
        + aBaseURI.hostPort
        + base_path
        );
      }
    debug("Adjusted to",aSpec,' vs ',aBaseURI.spec);

    return [ aSpec, aBaseURI ];
    },

  newURI: function(aSpec, aOriginCharset, aBaseURI) {
    // interestingly, the first time I see aBaseURI -> this xpi path
    try {
    debug("newURI",aSpec,' VS ',aBaseURI && aBaseURI.spec);

    // We have to repair leading "../" because nsIStandardURL doesn't seem to
    var objURI;
    if (aSpec.substr(0,3) == '../' && aBaseURI) {
        // convert back to "full" http so "domain lifting" is part of path and ../ works for it
        debug("Repair ../",aSpec,'vs',aBaseURI.spec);
        aBaseURI = this.to_http_scheme(aBaseURI);
        [aSpec, aBaseURI] = this.adjust_relative_path(aSpec, aBaseURI);
        debug("  Make http: from",aSpec,'+',aBaseURI.spec);
        objURI = this.make_nsIURL(aSpec, aOriginCharset, aBaseURI);
        objURI = this.from_http_scheme(objURI);
        debug("  Adjusted/rebuilt uri is",aSpec,'+',aBaseURI.spec,' -> ',objURI.spec);
        }
    else {
        objURI = this.make_nsIURL(aSpec, aOriginCharset, aBaseURI);
        }

    debug("--->uri",objURI.spec);

    return objURI;
    } catch (e) { debug(e); return null; }
  },

  newChannel: function(aURI)
  {
    try {
        debug("break down ",aURI.host,aURI.path);
        var wheretogo = this.to_http_scheme(aURI);

        var ioservice = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
        var uri = ioservice.newURI(wheretogo.spec, null, null);
        debug("backend uri",uri.spec);

        var backend_channel = ioservice.newChannelFromURI(uri).QueryInterface(Ci.nsIHttpChannel);
        // FIXME
        // Consider setting .referrer = current uri (what is current uri?)


        var apparent_channel = new ViaHTTPChannel(backend_channel);
        debug("apparent_channel const ",apparent_channel.constructor);
        apparent_channel.via = backend_channel;
        apparent_channel.originalURI = aURI;
        backend_channel.originalURI = aURI;
        apparent_channel.URI = aURI;
            debug("apparent originalURI",apparent_channel.originalURI.spec);
            debug("apparent URI",apparent_channel.URI.spec);
        return backend_channel;
        return apparent_channel;
    } catch (e) { debug(e); return null; }
  },
  classDescription: "Fosdem Basic Protocol Handler",
  contractID: "@mozilla.org/network/protocol;1?name=couchdb", // must match chrome.manifest
  classID: Components.ID('{7270a1fe-7b2f-4dc0-a935-664e9941d3a3}'), // must match chrome.manifest!, descriptive for now
  QueryInterface: XPCOMUtils.generateQI([Ci.nsIProtocolHandler])
}

function inspect_object(o) {
    var rez = "{";
    for (var a in o) {
        var v = o[a];
        if (v != null && v.constructor == Function) { v = "function "+a+"(...)" }
        rez = rez + "\t" + a + " : " + (v && v.toString().split("\n")[0]) + '\n';
        }
    rez = rez + "}";
    return rez;
    };

debug("pre");
function ViaHTTPChannel(via) { debug("new via") }
fakey_prototype = {
    // the whole point is provide a custom original_uri
    classDescription: "Hides a HTTP Channel",
    classID:          Components.ID("{f6a22d08-d9ff-489c-a696-1ba59f935b7e}"),
    contractID:       "@etc.etc.com/ViaHTTPChannel;1",
    QueryInterface: XPCOMUtils.generateQI([Ci.nsIHTTPChannel]),

    // FIXME: implement QueryInterface for all interfaces (see below)

    asyncOpen : function(a1, a2) { 
        try {
            debug("----OPEN---");
            debug("called VIA open",a1,a2); 
            debug("LOAD_NORMAL ", this.LOAD_NORMAL);
            debug("via.LOAD_NORMAL ", this.via.LOAD_NORMAL);
            debug("originalURI",this.originalURI.spec);
            debug("URI",this.URI.spec);
            debug("via uri",this.via.URI.spec);
            this.via.asyncOpen(a1, a2);
        } catch (e) { debug(e) }
        },

    };
(function() {
    
    debug("setup");
    
    for (let [iface_name, iface_methods] in Iterator({ 
        nsIRequest : [ 'cancel', 'isPending', 'resume', 'suspend' ],
        nsIChannel : [ ], // we skip open() on purpose, and are implementing asyncOpen
        nsIHTTPChannel : [ 'getRequestHeader', 'getResponseHeader', 'isNoCacheResponse',
            'isNoStoreResponse', 'setRequestHeader', 'setResponseHeader', 'visitRequestHeaders',
            'visitResponseHeaders',
            ]
        })) {
            
            // this is a lazy property: calculate then replaces the property w/value
            fakey_prototype[iface_name] = function(){ Object.defineProperty(this,iface_name,{ value : this.via.QueryInterface(Components.interfaces[iface_name])}); return iface};

            for (m in iface_methods) {
                // avoid actually know the arguments, nor caring about (not) returning a value
                fakey_prototype[m] = function() {debug("Called",m); return this[iface_name][m].call(this[iface_name], arguments)};
                }
        }
    // R/O
    for (var m in [ 
            // nisHTTPCHannel
            'requestSucceeded', 'responseStatus', 'responseStatusText',
            // nsIChannel
            'securityInfo', 'URI',
            'LOAD_CALL_CONTENT_SNIFFERS', 'LOAD_CLASSIFY_URI', 'LOAD_DOCUMENT_URI',
            'LOAD_RETARGETED_DOCUMENT_URI', 'LOAD_REPLACE', 'LOAD_INITIAL_DOCUMENT_URI', 'LOAD_TARGETED',
            // nsIRequest
            'name', 'status',
            'LOAD_NORMAL', 'LOAD_BACKGROUND', 'INHIBIT_CACHING', 'INHIBIT_PERSISTENT_CACHING',
            'LOAD_BYPASS_CACHE', 'LOAD_FROM_CACHE', 'VALIDATE_ALWAYS', 'VALIDATE_NEVER', 'VALIDATE_ONCE_PER_SESSION',
            'LOAD_ANONYMOUS'
        ]) {
        fakey_prototype.__defineGetter__(m, function() { debug("Get "+m); return this.via[m] });
        }

    // R/W
    for (var m in [ 
            // nisHTTPChannel
            'allowPipelining', 'redirectionLimit', 'referrer', 'requestMethod',  
            // nsIRequest
            'loadFlags', 'loadGroup', 
            // nsIChannel, skip originalURI
            'contentCharset', 'contentLength', 'contentType', 'notificationCallbacks', 'owner'
        ]) {
        fakey_prototype.__defineGetter__(m, function() { debug("Get "+m); return this.via[m] });
        fakey_prototype.__defineSetter__(m, function(v) { debug("Set "+m); this.via[m] = v });
        }

    
    debug("done setup");
    })();
ViaHTTPChannel.prototype=fakey_prototype;
debug("pre2");

if (XPCOMUtils.generateNSGetFactory) {
    debug("Make",AboutFosdem, ViaHTTPChannel);
  var NSGetFactory = XPCOMUtils.generateNSGetFactory([AboutFosdem, ViaHTTPChannel]);
  }
else
  var NSGetModule = XPCOMUtils.generateNSGetModule([AboutFosdem, ViaHTTPChannel]);

} catch (e) { debug(e) }
